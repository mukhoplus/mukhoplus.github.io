---
layout: post
title: 코딩테스트 낙서장3
excerpt: 벌써 3번째 낙서장이네요
date: 2022-08-29 22:25 +0000
last_modified_at: 2022-09-19 16:49:29 +0000
tags: [코딩테스트, muk]
toc:  true
---

부스트캠프 웹·모바일 7기 챌린지가 내 뇌를 리셋시켰어요!!<br>
파이썬 문법도 가물가물하네..?<br><br>

## 이진 탐색

- 태그: 이진 탐색, 이분 탐색, Binary Search

```python
def binarySearch(key, lst, start, end):
    if start > end:
        return -1
    
    mid = (start + end) // 2

    if lst[mid] == key:
        return mid
    
    if key < lst[mid]:
        return binarySearch(key, lst, start, mid-1)
    else:
        return binarySearch(key, lst, mid+1, end)

lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(binarySearch(-1, lst, 0, len(lst)-1)) # -1
print(binarySearch(3, lst, 0, len(lst)-1)) # 3
print(binarySearch(5, lst, 0, len(lst)-1)) # 5
print(binarySearch(11, lst, 0, len(lst)-1)) # -1

```

## 백트래킹

- 태그: 백트래킹, backtracking

```python
# N과 M (1) - 실3, https://www.acmicpc.net/problem/15649

def backtracking(cnt):
    if cnt == M:
        for x in output:
            print(x, end=' ')
        print()        
        return
    
    for i in range(1, N+1):
        if checked[i] == 0:
            checked[i] = 1
            output.append(i)
            backtracking(cnt+1)
            checked[i] = 0
            output.pop()

N, M = map(int, input().split())
checked = [0] * (N+1)
output = []

backtracking(0)

```

## DFS

- 태그: DFS, 깊이 우선 탐색, Depth First Search
- 설명: DFS로 풀게 되면 최대 100*100번의 탐색을 하게 되는데, Python의 재귀 탐색은 1000회가 최대이다.<br>
    따라서 ``sys.setrecursionlimit()`` 함수로 재귀 제한을 풀어주었다.<br>
    단순 탐색이면 상관없으나, 이 문제를 단순 탐색하게되면 불필요한 탐색을 할 가능성이 높다고 판단했다.<br>
    따라서 입력을 받을 때 높이의 최소값과 최대값을 계산해 반복문을 돌렸다.<br>
    그래프 이론, 부루트포스 알고리즘, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색

```python
# 안전 영역 - 실1, https://www.acmicpc.net/problem/2468

import sys
sys.setrecursionlimit(10000)

# U, D, L, R
dx = [+0, +0, -1, +1]
dy = [-1, +1, +0, +0]
def in_range(x, y):
    return 0 <= x < N and 0 <= y < N

def dfs(x, y, h):
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if in_range(nx, ny) and checked[nx][ny] == 0 and area[nx][ny] > h:
            checked[nx][ny] = 1
            dfs(nx, ny, h)

N = int(input())
in_min = 101
in_max = 0
area = []
for _ in range(N):
    temp = list(map(int, input().split()))
    in_min = min(min(temp), in_min)
    in_max = max(max(temp), in_max)
    area.append(temp)

safe = 1
for h in range(in_min, in_max+1):
    checked = [[0 for _ in range(N)] for _ in range(N)]
    cnt = 0
    for i in range(N):
        for j in range(N):
            if area[i][j] > h and checked[i][j] == 0:
                checked[i][j] = 1
                cnt += 1
                dfs(i, j, h)
    safe = max(safe, cnt)

print(safe)

```

## BFS

- 태그: BFS, 너비 우선 탐색, Breath First Search

```python
# 안전 영역 - 실1, https://www.acmicpc.net/problem/2468

from collections import deque

# U, D, L, R
dx = [+0, +0, -1, +1]
dy = [-1, +1, +0, +0]
def in_range(x, y):
    return 0 <= x < N and 0 <= y < N

def bfs(x, y, h):
    q = deque()
    q.append([x, y])
    checked[x][y] = 1

    while q:
        cx, cy = q.popleft()

        for i in range(4):
            nx = cx + dx[i]
            ny = cy + dy[i]

            if in_range(nx, ny) and checked[nx][ny] == 0 and area[nx][ny] > h:
                q.append([nx, ny])
                checked[nx][ny] = 1

N = int(input())
in_min = 101
in_max = 0
area = []
for _ in range(N):
    temp = list(map(int, input().split()))
    in_min = min(min(temp), in_min)
    in_max = max(max(temp), in_max)
    area.append(temp)

safe = 1
for h in range(in_min, in_max+1):
    checked = [[0 for _ in range(N)] for _ in range(N)]
    cnt = 0
    for i in range(N):
        for j in range(N):
            if area[i][j] > h and checked[i][j] == 0:
                checked[i][j] = 1
                cnt += 1
                bfs(i, j, h)
    safe = max(safe, cnt)

print(safe)

```

## 다익스트라

- 태그: 다익스트라, dijkstra, 그래프 최단 경로, 그리드
- 특정 노드에서 다른 노드로 가는 각각의 최단 경로를 구할 때 사용, 음수를 가지는 간선이 없다.
- BFS에서는 ``queue(deque)``를 사용하지만, 다익스트라에서는 ``heapq``를 사용한다.
    - heapq의 정렬 기준은 **오름차순(1, 2, 3, ...)**만을 지원한다.
    - 따라서, heapq에서 내림차순을 적용하고 싶다면 정렬의 기준이 되는 값에 ``-``를 붙여 **음수화**해야 한다.

```python
# 최단경로 - 골4, https://www.acmicpc.net/problem/1753

import heapq, sys
input = sys.stdin.readline
INF = int(1e9)

def dijkstra(k):
    q = []
    heapq.heappush(q, (0, k))

    while q:
        w, s = heapq.heappop(q)
        if dist[s] < w:
            continue

        for end_list in graph[s]:
            e, w_ = end_list

            cost = w + w_
            if cost < dist[e]:
                dist[e] = cost
                heapq.heappush(q, (cost, e))

V, E = map(int, input().split())
K = int(input())-1

graph = [[] for _ in range(V)]
for _ in range(E):
    s, e, w = map(int, input().split())
    graph[s-1].append([e-1, w])

dist = [INF for _ in range(V)]
dist[K] = 0

dijkstra(K)

for w in dist:
    print(w if w != INF else 'INF')

```

## 플로이드 워셜

- 태그: floyd warshall, 그래프 최단 경로, 다이나믹 프로그래밍, DP
- 설명: 모든 지점에서 다른 모든 지점까지의 최단 경로를 **모두** 구해야 하는 경우 사용

```python
# 경로 찾기 - 실1, https://www.acmicpc.net/problem/11403

INF = int(1e9)

N = int(input())
graph = []
for _ in range(N):
    graph.append(list(map(int, input().split())))

for m in range(N):
    for i in range(N):
        for j in range(N):
            if graph[i][j] == 1 or (graph[i][m] == 1 and graph[m][j] == 1):
                graph[i][j] = 1

for i in range(N):
    for j in range(N):
        print(graph[i][j], end=' ')
    print()

```
