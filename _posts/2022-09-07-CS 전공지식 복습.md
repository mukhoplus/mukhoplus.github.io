---
layout: post
title: CS 전공지식 복습
excerpt: 진작 공부 열심히할걸~
date: 2022-09-07 12:23 +0000
last_modified_at: 2022-09-07 16:26:38 +0000
tags: [CS]
toc:  true
---

`면접을 위한 CS 전공지식노트(주홍철 지음)` 책의 내용을 정리했습니다.<br><br>

## 디자인 패턴

- 싱글톤 패턴: 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴으로, 인스턴스 생성 비용을 아낄 수 있다.
- 의존성 주입(DI): 모듈 간의 결합을 느슨하게 만듬
- passport: Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 전략을 기반으로 인증할 수 있게 한다. 
<br>

- 옵저버 패턴: 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메소드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다. 
<br>

- 프록시 서버: 서버 앞단에 둬서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 하는 서버이다. 포트 번호를 바꾸어 사용자가 실제 서버의 포트에 접근하지 못하게 할 수 있고 공격자의 DDOS 공격을 차단하거나 CDN을 프록시 서버로 달아서 캐싱 처리를 용이하게 할 수 있다. 

- 상속: 자식 클래스가 부모 클래스의 메소드를 상속받아 사용하며 자식 클래스에서 추가 및 확장을 할 수 있는 것으로, 재사용성, 중복성의 최소화가 이루어진다.
- 구현: 부모 인터페이스를 자식 클래스에서 재정의하여 구현하는 것으로, 상속과는 달리 반드시 부모 클래스의 메소드를 재정의하여 구현해야 한다.
- 프록시 서버: 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램으로, nginx가 있다.
- nginx: 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버로, 주로 Node.js 서버 앞단의 프록시 서버로 활용된다. - 보안성 강화
<br>

- MVC(ex- React.js): 앱의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있고, 재사용성과 확장성이 용이하다.
    - 모델: 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 의미한다.
    - 뷰: inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타낸다.
    - 컨트롤러: 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 모델의 뷰의 생명주기를 관리한다. 
<br>

- 함수형 프로그래밍: 순수 함수를 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임이다.
    - 순수 함수: 출력이 입력에만 의존하는 것이다.
    - 고차 함수: 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것이다.
    - 일급 객체: 변수나 메소드에 함수를 할당할 수 있고, 함수 안에 함수를 매개변수로 담을 수 있고, 함수가 함수를 반환할 수 있는 특징을 가진 언어이다. 
<br>

- 객체지향 프로그래밍의 특징
    - 추상화: 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것이다.
    - 캡슐화: 객체의 속성과 메소드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것이다.
    - 상속성: 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것이다.
    - 다형성: 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것이다.
    - 오버로딩: 같은 이름을 가진 메소드를 여러 개 두는 것으로 메소드의 타입, 매개변수의 유형, 개수 등으로 여러 개를 둘 수 있다. 정적 다형성이다.
    - 오버라이딩: 주로 메소드 오버라이딩을 말하며, 상위 클래스로부터 상속받은 메소드를 하위 클래스가 재정의하는 것이다. 동적 다형성이다. 
- 객체지향 프로그래밍 설계
    - 단일 책임 원칙: 모든 클래스는 각각 하나의 책임을 가져야 한다.
    - 개방-폐쇄 원칙: 기존의 코드는 잘 변경하지 않아야 하고, 확장은 쉽게 할 수 있어야 한다.
    - 리스코프 치환 원칙: 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 인터페이스 분리 원칙: 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 한다.
    - 의존 역전 원칙: 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다. 
<br>

## 네트워크

- 네트워크: 노드와 링크가 서로 연결되어 있거나 연결되어 있지 않은 집합체로 처리량이 높고 지연 시간이 짧아야 한다. 트리, 버스, 스타, 링, 메시 토폴로지가 있다. 
<br>

- TCP/IP 4계층 모델
    - 응용 계층(세표응): FTP/HTTP/SSH/SMTP/DNS 등 응용 프로그램이 사용되는 프로토콜 계층이며, 서비스를 실질적으로 사람들에게 제공하는 계층이다.
    - 전송 계층(전): TCP/UDP/QUIC. 송신자와 수신자를 연결하는 통신 서비스를 제공하며 연결 지향 제이터 스트림 지원, 신뢰성과 흐름 제어를 제공하며, 응용과 인터넷 계층 사이의 데이터가 전달될 때의 중계 역할을 한다.
        - TCP: 패킷 사이의 순서를 보장하고, 연결 지향 프로토콜을 사용하여 연결을 해 신뢰성을 구축하고 수신 여부를 확인하며 가상회선 패킷 교환 방식을 사용한다.
        - UDP: 순서를 보장하지 않고, 수신 여부를 확인하지 않으며 단순히 데이터만 주는 데이터그램 패킷 교환 방식을 사용한다.
    - 인터넷 계층(네): IP/ARP/ICMP. 장치로부터 받은 네트워크 패킷을 IP 주소로 지정된 목적지로 전송하기 위해 사용되는 계층이다.
    - 링크 계층(물데): 이더넷. 실질적으로 데이터를 전달하며 장치 간에 신호를 주고받는 규칙을 정하는 계층이다. 

- 3-way handshake
    1. SYN: 클라이언트는 서버에 ISN을 담아 SYN을 보낸다.
    2. SYN+ACK: 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며, 승인번호로 클라이언트의 ISN+1을 보낸다.
    3. ACK: 클라이언트는 서버의 ISN+1한 값인 승인번호를 담아 ACK를 서버에 보낸다.
- 4-way handshake
    1. 클라이언트는 FIN으로 설정된 세그먼트를 보낸다. FIN_WAIT_1 상태로 바뀌고 서버의 응답을 기다린다.
    2. 서버는 클라이언트로 ACK 승인 세그먼트를 보낸다. CLOSE_WAIT 상태로 바뀌고, 클라이언트는 세그먼트를 받으면 FIN_WAIT_2 상태로 바뀐다.
    3. 서버는 ACK를 보내고 일정 시간 후에 클라이언트에 FIN이라는 세그먼트를 보낸다.
    4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 된다. 이후 클라이언트는 일정 시간을 대기한 후 연결이 닫히고, 클라이언트와 서버의 모든 자원의 연결이 해제된다. 
<br>

- 유선 LAN - 이더넷: IEEE802.3, 전이중화 통신(양쪽 장치가 동시에 송수신할 수 있는 방식). 트위스트 페어 케이블(랜선), 광섬유 케이블
CSMA/CD: 반이중화 통신으로, 한 경로로 데이터를 보내고, 데이터를 보낸 이후 충돌이 발생한다면 일정 시간 이후 재전송하는 방식이다. 
- 무선 LAN: 반이중화 통신- 양쪽 장치는 서로 통신할 수 있지만, 동시에는 통신할 수 없는 방식이다.
- CSMA/CA: 반이중화 통신 중 하나로 장치에서 데이터를 보내기 전에 캐리어 감지 등으로 사전에 가능한 한 충돌을 방지하는 방식을 사용한다. 
- 2.4GHz: 장애물에 강한 특성을 가지지만 전파 간섭이 일어나는 경우가 많다.
- 5GHz: 사용 가능한 채널 수가 많고 동시에 사용할 수 있기 때문에 상대적으로 깨끗한 전파 환경을 구축할 수 있다. 
- 와이파이: 전자기기들이 무선 LAN 신호에 연결할 수 있게 하는 기술로, 무선 접속 장치(AP)-공유기가 있어야 한다. 
<br>

- 캡슐화: 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고, 해당 계층의 헤더를 삽입하는 과정이다.
- 비캡슐화: 하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정이다.
- PDU: Protocol Data Unit으로, 네트워크의 어떤 계층에서 계층으로 전달될 때의 데이터의 단위이다. 헤더(제어 관련 정보)-페이로드(데이터)로 구성되어 있다. 
<br>

- 응용 계층 - L7 스위치
- 인터넷 계층 - 라우터, L3 스위치
- 데이터 링크 계층 - L2 스위치, 브리지
- 물리 계층 - NIC(네트워크 인터페이스 카드), 리피터-패킷 신호 증폭, AP-패킷 복사 
<br>

- ARP: Address Resolution Protocol로, IP 주소를 실제 주소인 MAC 주소로 변환한다.
- 게이트웨이: 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할을 하는 컴퓨터나 소프트웨어이다. 
<br>

- IPv4: 32비트를 8비트 단위로 나눈 주소이다.
- IPv6: 64비트를 16비트 단위로 나눈 주소이다. 
<br>

- DHCP: Dynamic Host Configuration Protocol로, IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜이다.
- NAT: Network Address Translation으로, 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법이다. 공인 IP와 사설 IP로 나눠서 많은 주소를 사용할 수 있다. 
<br>

- HTTP/1.0: 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되었고, 이로 인해 RTT(패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸리는 시간이며 패킷 왕복 시간) 증가를 불러오게 되었다.
    - 이를 해결하기 위해 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩을 사용했다.
- HTTP/1.1: 매번 TCP 연결을 하는 것이 아니라 한 번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀌었다. 헤더에 쿠키 등 많은 메타데이터가 들어 있고 압축이 되지 않아 무거웠다.
- HTTP/2: 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있으며 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다.
- HTTPS: HTTP/2 위에서 동작하며, 응용 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청이다. 통신을 암호화한 것이다.
    - SSL/TLS: 전송 계층에서 보안을 제공하는 프로토콜이다. 
- 해싱 알고리즘: 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘이다.
- SHA-256 알고리즘: 해시 함수의 결과값이 256비트인 알고리즘이며 비트 코인을 비롯한 많은 블록체인 시스템에서도 사용한다.
- HTTP/3: QUIC라는 계층 위에서 돌아가며 TCP 기반이 아닌 UDP 기반으로 돌아간다. 3-way handshake 과정이 없으므로 초기 연결 설정 시 지연 시간이 감소된다. QUIC는 순방향 오류 수정 메커니즘(FEC)이 적용되어 있는데, 이는 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이며 열악한 네트워크 환경에서도 낮은 패킷 손실률을 자랑한다.

## 운영체제

- 운영체제: 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 인터페이스로, 한정된 메모리나 시스템 자원을 효율적으로 분배한다. CPU 스케줄링과 프로세스 관리, 메모리 관리, 디스크 파일 관리, I/O 디바이스 관리 등을 담당한다.
    - 유저 프로그램 
    - **GUI**: 단순 명렁어 창이 아닌 아이콘을 마우스로 클릭하는 단순한 동작으로 컴퓨터와 상호 작용할 수 있도록 하는 인터페이스
    - **시스템콜**: 운영체제가 커널에 접근하기 위한 인터페이스로, 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용한다.
        - 메모리(프로세스-스레드) -> 시스템콜 -> 커널 -> OS의 구조이다.
        - modebit: 시스템콜이 작동될 때 유저 모드(1)와 커널 모드(0)을 구분하는 플래그 변수이다.
    - **커널**: 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할을 한다.
    - **드라이버**
    - 하드웨어

- CPU: 인터럽트에 의해 메모리에 존재하는 명령어를 해석하여 실행하는 역할을 하며 산술논리연산장치, 제어장치, 레지스터로 구성되어 있다.
- 제어장치: 프로세스 조작을 지시하는 CPU의 한 부품으로, 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다.
- 레지스터: CPU 안에 있는 매우 빠른 임시기억장치로, CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 매우 빠르다.
- 산술논리연산장치(ALU): 두 숫자의 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로이다.
    1. 제어장치가 메모리와 레지스터에 계산할 값을 로드한다.
    2. 제어장치가 레지스터에 있는 값을 계산하라는 명령을 산술논리연산장치에 명령한다.
    3. 제어장치가 계산된 값을 다시 '레지스터에서 메모리로' 계산한 값을 저장한다.

- 인터럽트: 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것으로 IO 디바이스, 산술 연산, 프로세스 오류 등으로 발생한다. 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉜다.
- DMA 컨트롤러: I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치로, CPU 부하를 막아준다.

- 메모리 계층
    - 레지스터: CPU 안에 있는 작은 메모리로 휘발성, 속도가 매우 빠름, 기억 용량이 가장 적은 특징이 있다.
    - 캐시(L1, L2 캐시): 휘발성, 속도 빠름, 기억 용량이 적은 특징이 있다.
    - 메모리/주기억장치: RAM을 가리키며 휘발성, 속도 보통, 기억 용량이 보통인 특징이 있다.
    - 저장장치/보조기억장치: HDD, SSD를 가리키며 휘발성, 속도 낮음, 기억 용량이 많은 특징이 있다.
- RAM: 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달하는 역할을 한다.
- 캐시: 데이터를 미리 복사해 놓는 임시 저장소이자, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다. 캐시를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다. 메모리와 CPU 사이의 속도 차이가 크기 때문에 '레지스터'를 두어 속도 차이를 해결하는데, 계층과 계층 사이에서 속도 차이를 해결하는 계층을 '캐싱 계층'이라고 한다.
<br>

- 시간 지역성: 최근 사용한 데이터에 다시 접근하려는 특성이다.
- 공간 지역성: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성이다.
- 캐시 hit과 캐시 miss: 캐시에서 원하는 데이터를 찾았다면 캐시 히트, 해당 데이터가 캐시에 없다면 주기억장치로 가서 데이터를 찾아오는 것을 캐시 미스라고 한다.

- 웹 브라우저의 캐시: 사용자의 커스텀 정보와 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 본인 인증이나 중복 요청 방지를 위해 쓰인다.
    - 쿠키: 만료기한이 있는 키-값 저장소로, 주로 서버에서 만료기한을 정한다.
    - 로컬 스토리지: 만료기한이 없는 키-값 저장소로, 도메인 단위로 저장, 생성되고 클라이언트에서만 수정 가능하다.
    - 세션 스토리지: 만료기한이 없는 키-값 저장소로, 탭 단위로 세션 스토리지를 생성하고 탭을 닫을 때 해당 데이터가 삭제된다. 클라이언트에서만 수정 가능하다.

- 가상 메모리: 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것이다. 이때 가상적으로 주어진 주소를 가상 주소(logical address)라고 하며, 실제 매모리상에 있는 주소를 실제 주소(physical address)라고 한다. 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환된다. 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 '페이지 테이블'로 관리된다. 이때 속도 향상을 위해 TLB를 사용한다.
- TLB: 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다.

- 메모리 연속 할당: 메모리에 연속적으로 공간을 할당하는 것이다.
    - 고정 분할 방식: 메모리를 미리 나누어 관리하는 방식으로 융통성이 없으며, 내부 단편화가 발생한다.
        - 내부 단편화(Internal Fragmentation)는 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상이다.
    - 가변 분할 방식: 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 발생하지 않지만 외부 단편화가 발생한다.
        - 외부 단편화(External Fragmentation)는 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상이다.
        - 최초적합(first fit): 위쪽이나 아래쪽부터 시작하여 홀을 찾으면 바로 할당한다.
        - 최적적합(best fit): 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.
        - 최악적합(worst fit): 프로세스의 크기가 가장 많이 차이가 나는 홀에 할당한다.
- 메모리 불연속 할당
    - 페이징: 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다. 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.
    - 세그먼테이션: 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식이다. 프로세스는 '코드, 데이터, 스택, 힙' 등으로 이루어지는데, 코드와 데이터 등 이를 기반으로 나눌 수도 있으며 함수 단위로 나눌 수도 있다. 공유와 보안 측면에서는 좋지만 홀 크기가 균일하지 않다.
- 페이지 교체 알고리즘: 메모리는 한정되어 있기 때문에 스와핑이 많이 일어난다. 하지만 스와핑이 많이 일어나면 성능 저하가 일어나기 때문에 스와핑이 최대한 적게 발생하도록 설계되어야 하며, 페이지 교체 알고리즘을 기반으로 스와핑이 일어난다.
    - 오프라인 알고리즘: 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘으로 이론상 가장 좋은 방법이지만 구현할 수 없어 전투력 측정기 역할을 한다.
    - FIFO: 가장 먼저 온 페이지를 교체 영역에 가장 먼저 좋는 방법이다.
    - LRU: Least Recently Used로, 참조가 가장 오래된 페이지를 바꾼다. 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제점이 있다. 주로 해시 테이블과 이중 연결 리스트를 통해 구현하는데 해시 테이블은 이중 연결 리스트에서 O(1)을 만족시키기 위해 쓰고, 이중 연결 리스트는 한정된 메모리를 의미한다.
    - NRU: Not Used Recently로, LRU에서 발전한 방법이다. Clock 알고리즘이라고 하며 먼저 0과 1을 가진 **비트**를 둔다. 1은 최근에 참조되었고 0은 참조되지 않음을 의미한다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하면서 비트를 1로 바꾸는 알고리즘이다.
    - LFU: Least Frequently Used로, 참조 횟수가 가장 적은 페이지를 교체한다.

- 프로세스: 컴퓨터에서 실행되고 있는 프로그램을 말하며, CPU 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다.
- 스레드: 프로세스 내 작업의 흐름이다.

- 컴파일 과정
    1. 전처리: 소스 코드의 주석을 제거하고 헤더 파일을 병합하여 매크로를 치환한다.
    2. 컴파일러: 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.
    3. 어셈블러: 어셈블러를 목적 코드(object code)로 변환한다. 이때 확장자는 OS마다 다른데 리눅스에서는 ``.o``이다.
    4. 링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다. ``.exe`` 또는 ``.out`` 확장자를 가진다.
    - 라이브러리
        - 정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식이며, 시스템 환경 등 외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 떨어지는 단점이 있다.
        - 동적 라이브러리: 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식이며, 메모리 효율성에서의 장점이 있지만 외부 의존도가 높아진다는 단점이 있다.

- 프로세스의 상태
    - 생성(Create): 프로세스가 생성된 상태를 의미하며 ``fork()`` 또는 ``exec()`` 함수를 통해 생성한다. 이때 PCB가 할당된다.
        - fork(): 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수이다. 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않는다.
        - exec(): 새롭게 프로세스를 생성하는 함수이다.
    - 대기(Ready): 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태이다.
        - 대기 중단(Ready Suspended): 메모리 부족으로 일시 중단된 상태이다.
    - 실행(Running): CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태로, CPU burst가 일어났다고 표현하기도 한다.
    - 중단(Blocked): 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태이다. I/O 디바이스에 의한 인터럽트로 이런 현상이 많이 발생한다.
        - 일시 중단(Blocked Suspended): 대기 중단과 유사하며, 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태이다.
    - 종료(Terminated): 메모리와 CPU 소유권을 모두 놓고 가는 상태이다. 자연스럽게 종료되는 경우도 있지만 부모 프로세스가 자식 프로세스를 강제 종료시키는 비자발적 종료(abort)가 일어나는 경우도 있다. 자식 프로세스에 할당된 자원의 한계치를 넘어서거나, 부모 프로세스가 종료되거나, 사용자가 process.kill 등 여러 명령어로 프로세스를 종료할 때 발생한다.

- 프로세스의 메모리 구조
    - 동적 영역: 스택은 위 주소부터 할당되고 힙은 아래 주소부터 할당된다.
        - **스택**: 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되며 '동적'인 특징을 가진다. 함수가 함수를 재귀적으로 호출하면서 동적으로 크기가 늘어날 수 있는데, 이때 힙과 스택의 메모리 영역이 겹치면 안 되기 때문에 힙과 스택 사이의 공간을 비워 놓는다.
        - **힙**: 동적 할당할 때 사용되며 런타임 시 크기가 결정된다. '동적'인 특징을 가진다.
    - 정적 영역
        - **데이터 영역**: 전역변수와 정적변수가 저장되고, '정적'인 특징을 갖는 프로그램이 종료되면 사라지는 변수가 들어 있는 영역이다. 데이터 영역은 BSS 영역(Segment)과 Data 영역으로 나뉜다.
            - BSS 영역: 초기화가 되지 않는 변수가 0으로 초기화되어 저장된다.
            - Data 영역: 0이 아닌 다른 값으로 할당된 변수들이 저장된다.
        - **코드 영역**: 프로그램에 내장되어 있는 소스 코드가 들어가는 영역이다. 수정 불가능한 기계어로 저장되어 있으며 '정적'인 특징을 가진다.
- PCB: Process Control Block, 프로세스 제어 블록은 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'이다. 프로세스가 생성되면 OS가 생성한다.
    - 프로그램이 실행되면 프로세스가 실행되고 프로세스 주소 값들에 앞서 스택, 힙 등의 구조를 기반으로 메모리가 할당된다. 그리고 이 프로세스의 메타데이터들이 PCB에 저장되어 관리된다. 이는 프로세스의 중요한 정보를 포함하고 있기 때문에 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리된다.
    - 프로세스 스케줄링 상태, 프로세스 ID, 프로세스 권한, 프로그램 카운터, CPU 레지스터, CPU 스케줄링 정보, 계정 정보, I/O 상태 정보 등으로 이루어져 있다.
- 메타데이터: 데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터이다.

- Context Switching: PCB를 교환하는 과정으로 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다. 컴퓨터는 많은 프로그램을 동시에 실행하는 것처럼 보이지만 어떠한 시점에 실행되고 있는 프로세스는 단 1개(**싱글코어 기준**)이며, 많은 프로세스가 동시에 구동되는 것처럼 보이는 것은 다른 프로세스와이 컨텍스트 스위칭이 아주 빠른 속도로 실행되기 때문이다.
    - 비용: 캐시미스. 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생한다.
    - 스레드에서도 컨텍스트 스위칭이 일어난다. **스레드는 스택 영역을 제외한 모든 메모리를 공유**하기 때문에 스레드 컨텍스트 스위칭의 경우 비용이 더 적고 시간이 더 적게 걸린다.

- 멀티프로세싱: 여러 개의 프로세스, 즉 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 의미한다. 하나 이상의 일을 **병렬로 처리**할 수 있으며 특정 프로세스에 문제가 생겨도 다른 프로세스를 사용하면 되기 때문에 신뢰성이 높다.
- IPC: Inter Process Communication으로 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘이다. 클라이언트는 데이터를 요청하고 서버는 클라이언트 요청에 응답하는 것도 IPC의 예시이다. IPC의 종류로는 공유 메모리, 파일, **소켓**, 익명 파이프, 명명 파이프, 메시지 큐가 있으며, 이들은 메모리가 (스택을 제외하면)완전히 공유되는 스레드보다는 속도가 느리다.
    - 소켓: 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터를 의미하며 TCP와 UDP가 있다.
    - 익명 파이프: 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받으며, 단방향 방식의 읽기 전영, 쓰기 전용 파이프를 만들어서 작동하는 방식이다. 이는 부모-자식 프로세스 간에만 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능하다.
    - 명명된 파이프: 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위한 명명된 단방향/이중 파이프를 말한다. 클라이언트/서버 통신을 위한 별도의 파이프를 제공하며, 여러 파이프를 동시에 사용할 수 있다. 컴퓨터의 프로세스/다른 네트워크상의 컴퓨터와도 통신할 수 있다.

- 스레드: 프로세스의 실행 가능한 가장 작은 단위로, 프로세스는 여러 스레드를 가질 수 있다. 코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와는 달리 스레드는 코드, 데이터, 힙은 스레드끼리 서로 공유한다.
- 멀티스레딩: 프로세스 내 작업을 여러 개의 스레드, 즉 멀티스레드로 처리하는 기법이며 스레드끼리 서로 자원을 공유하기 때문에 효율성이 높다. 또한 동시성-서로 독립적은 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것-에도 큰 장점이 있다. 하지만 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어져 있는 프로세스에 영향을 줄 수 있는 단점이 있다.

- 공유 자원: 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이트 등의 자원이나 변수 등을 의미한다.
- 경쟁 상태(Race Condition): 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황으로, 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결괏값에 영향을줄 수 있는 상태이다.
- 임계 영역: 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역이다. 이를 해결하기 위한 방법은 크게 **뮤텍스**, **세마포어**, **모니터** 세 가지가 있으며, 이 방법 모두 ``상호 배제``, ``한정 대기``, ``융통성``이라는 조건을 만족한다. 이 방법들의 토대가 되는 메커니즘은 잠금(Lock)이다.
    - 상호 배제: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
    - 한정 대기: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.
    - 융통성: 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.
    - ``뮤텍스(Mutex)``: 공유 자원을 사용하기 전에 설정하고, 사용한 후에 해제하는 잠금이다. 잠금이 설정되면 다른 스레드는 잠긴 코드 영역에 접근할 수 없다. 뮤텍스는 하나의 상태(잠금/잠금 해제)만 가진다.
    - ``세마포어(Semaphore)``: 일반화된 뮤텍스로, 간단한 정수 값과 두 가지 함수 ``wait``(P 함수라고도 함) 및 ``signal``(V 함수라고도 함)로 공유 자원에 대한 접근을 처리한다. wait()은 자신의 차례가 올 때까지 기다리는 함수이고 signal()은 다음 프로세스로 순서를 넘겨주는 함수이다.
        - 프로세스가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고 프로세스가 공유 자원을 해제하면 세마포어에서 signal() 작업을 수행한다. 세마포어에는 조건 변수가 없고 프로세스가 세마포어 값을 수정할 때 다른 프로세스는 동시에 세마포어 값을 수정할 수 없다.
        - **바이너리 세마포어**는 0과 1의 두 가지 값만 가질 수 있는 세마포어이다. 구현의 유사성 때문에 뮤텍스는 바이너리 세마포어라고 할 수 있지만, 뮤텍스는 리소스에 대한 접근을 동기화하는 데 사용되는 잠금 메커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 메커니즘이다.
        - **카운팅 세마포어**는 여러 개의 값을 가질 수 있는 세마포어로 여러 자원에 대한 접근을 제어하는 데 사용한다.
    - ``모니터(Monitor)``: 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다. 모니터큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다. 세마포어보다 구현하기 쉬우며 모니터에서 상호 배제는 자동인 반면에, 세마포어에서는 상호 배제를 명시적으로 구현해야 한다는 차이점이 있다.

- 교착 상태(Deadlock): 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다. 프로세스 A가 프로세스 B의 어떤 자원을 요청할 때 프로세스 B도 프로세스 A가 점유하고 있는 자원을 요청하는 것이다.
    - 교착 상태의 원인
        - **상호 배제**: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능하다.
        - **점유 대기**: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태이다.
        - **비선점**: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
        -- **환형 대기**: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황이다.
    - 교착 상태의 해결 방법
        1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다.
        2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 '은행원 알고리즘'을 사용한다.
            - 은행원 알고리즘: 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘이다.
        3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 하나씩 지운다.
        4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다. 현대 운영체제는 이 방법을 채택했다.

- CPU 스케줄링 알고리즘: CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, ready queue에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표로 한다.
    - 비선점형(Non-preemptive): 프로세스가 스스로 CPU 소유권을 포기하는 방식으로, 강제로 프로세스를 종료하지 않는다. 따라서 컨텍스트 스위칭으로 인한 부하가 적다.
        - FCFS: First Come First Served로 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘이다. 길게 수행되는 프로세스 때문에 ready queue에서 오래 기다리는 현상인 convoy effect가 발생할 수 있다.
        - SJF: Short Job First로, 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘이다. 긴 시간을 가진 프로세스가 실행되지 않은 현상(Starvation)이 일어나며, 평균 대기 시간이 가장 짧다. 하지만 실제로는 실행 시간을 알 수 없기 때문에 과거에 실행했던 시간을 토대로 추측해서 사용한다.
        - 우선순위: 기존의 SJF 스케줄링의 경우 긴 시간을 가진 프로세스가 실행되지 않는 현상이 있었는데, 이를 해결하기 위해 '오래된 작업일수록 우선순위를 높이는 방법'인 aging을 통해 단점을 보완한 알고리즘이다.
    - 선점형(Preemptive): 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고, 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식이다.
        - Round Robin(RR): 현대 컴퓨터가 쓰는 스케줄링인 우선순위 스케줄링(Priority Scheduling)의 일종으로 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 ready queue의 뒤로 가는 알고리즘이다. 할당 시간이 너무 길면 FCFS가 되고 너무 짧으면 컨텍스트 스위칭이 잦아져서 오버헤드, 즉 비용이 커진다. 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이 있다.
        - SRF: SJF는 중간에 실행 시간이 더 짧은 작업이 들어와도 기존에 수행하던 작업을 모두 수행하고 그 다음 짧은 작업을 이어나가는데, SRF는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘이다.
        - Multi-Level Queue: 다단계 큐는 우선순위에 따른 ready queue를 여러 개 사용하고, queue마다 RR이나 FCFS, SJF 등 다른 스케줄링 알고리즘을 적용한 것을 말한다. 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 그만큼 유연성이 떨어진다.

## 자료구조

- Data Structure는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합이다.

- 시간 복잡도: 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계로, 어떠한 알고리즘의 로직이 얼마나 오랜 시간이 걸리는지를 나타내는 데 쓰인다.
    - 빅오 표기법: 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것이다. 가장 영향을 많이 끼치는 항의 상수 인자를 빼고 나머지 항을 없앤 것이다.
- 공간 복잡도: 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양이다. 정적 변수로 선언된 것 말고도 동적으로, 재귀적인 함수로 인해 공간을 계속해서 필요로 할 경우도 포함된다. C++에서 ``int a[1004]`` 배열은 1004 * 4 byte의 크기를 가진다.

- 자료구조의 평균 시간 복잡도

|자료구조|접근|탐색|삽입|삭제|
|:---|:---:|:---:|:---:|:---:|
|배열(array)|O(1)|O(n)|O(n)|O(n)|
|스택(stack)|O(n)|O(n)|O(1)|O(1)|
|큐(queue)|O(n)|O(n)|O(1)|O(1)|
|단일 연결 리스트(singly linked list)|O(n)|O(n)|O(1)|O(n)|
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(1)|O(1)|O(1)|O(1)|
|이진 탐색 트리(BST)|O(logn)|O(logn)|O(logn)|O(logn)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|

- 자료구조의 최악 시간 복잡도

|자료구조|접근|탐색|삽입|삭제|
|:---|:---:|:---:|:---:|:---:|
|배열(array)|O(1)|O(n)|O(n)|O(n)|
|스택(stack)|O(n)|O(n)|O(1)|O(1)|
|큐(queue)|O(n)|O(n)|O(1)|O(1)|
|단일 연결 리스트(singly linked list)|O(n)|O(n)|O(n)|O(n)|
|이중 연결 리스트(doubly linked list)|O(n)|O(n)|O(1)|O(1)|
|해시 테이블(hash table)|O(n)|O(n)|O(n)|O(n)|
|이진 탐색 트리(BST)|O(n)|O(n)|O(n)|O(n)|
|AVL 트리|O(logn)|O(logn)|O(logn)|O(logn)|
|레드 블랙 트리|O(logn)|O(logn)|O(logn)|O(logn)|

- 선형 자료 구조: 요소가 일렬로 나열되어 있는 자료구조이다.
    - 연결 리스트: 데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조이다. 삽입과 삭제 시 O(1)이 걸리며 탐색에는 O(n)이 걸린다. 맨 앞의 노드를 head, (맨 뒤의 노드를 tail이)라고 하며, 각 노드는 prev 포인터, next 포인터와 데이터를 가진다.
        - 싱글 연결 리스트: next 포인터만 가진다.
        - 이중 연결 리스트: next 포인터와 prev 포인터를 가진다.
        - 원형 이중 연결 리스트: 이중 연결리스트와 같지만 마지막 노드의 next 포인터가 head 노드를 가리키는 것이다.
    - 배열: (C++)같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합이다. 중복을 허용하고 순서가 있다. 정적 배열의 경우 탐색이 O(1)이 되어 random access가 가능하다. 삽입과 삭제 시에는 O(n)이 걸린다. 배열은 인덱스에 해당하는 원소를 빠르게 접근해야 하거나 간단하게 데이터를 쌓고 싶을 때 사용한다.
        - 데이터 추가와 삭제를 많이 하는 경우 연결 리스트를, 탐색을 많이 하는 것은 배열로 하는 것이 좋다.
    - 벡터: 동적으로 요소를 할당할 수 있는 동적 배열이다. 컴파일 시점에 개수를 모른다면 벡터를 사용해야 한다. 중복을 허용하고 순서가 있으며 랜덤 접근이 가능하다. 탐색과 맨 앞/뒤의 요소를 삭제하거나 삽입하는 데 O(1)이 걸리며, 맨 앞/뒤가 아닌 요소를 삭제하거나 삽입하는 데 O(n)의 시간이 걸린다.
    - 스택: LIFO 성질을 가진 자료 구조이다. 재귀적인 함수, 깊이 우선 탐색(DFS) 등의 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 쓰인다. 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다. push로 값을 넣고, pop으로 값을 뺀다.
    - 큐: FIFO 성질을 가진 자료 구조이다. 삽입 및 삭제에 O(1), 탐색에 O(n)이 걸린다. CPU 작업을 기다리는 프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색(BFS), 캐시 등에 사용한다. enqueue로 back에 값을 넣고, dequeue로 front에서 값을 뺀다.
- 비선형 자료 구조: 일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조이다. 일반적으로 트리나 그래프를 의미한다.
    - 그래프: 정점과 간선으로 이루어진 자료 구조이다.
        - 어떤 곳에서 어떤 곳으로 무언가를 통해 간다고 했을 때, '어떤 곳'은 **정점(Vertex)**이고, '무언가'는 **간선(Edge)**이다. 간선의 방향성이 없다면 '무방향 간선'이고, 한 정점에서 다른 정점 방향으로 이동하는 간선이 단방향인 경우 '단방향 간선', 양 방향으로 이동하는 간선이 있을 경우 '양방향 간선'이다.
        - 어떤 정점으로 나가는 간선을 해당 정점의 outdegree라고 하며, 들어오는 간선을 해당 정점의 indegree라고 한다.
        - 정점의 약자는 ``V`` 또는 ``U``이다.
        - 가중치: 간선과 정점 사이에 드는 비용이다.
    - 트리: 그래프 중 하나로 그래프의 특징처럼 정점과 간서으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합이다. 트리의 특징은 다음과 같다.
        1. 부모, 자식 계층 구조를 가진다. 같은 경로 상에서 어떤 노드보다 위에 있으면 부모, 아래에 있으면 자식 노드가 된다.
        2. ``V - 1 = E``라는 특징이 있다. 이때 ``E``는 **간선 수**, ``V``는 **노드 수**이다.
        3. 임의의 두 노드 사이의 경로는 '유일무이'하게 '존재'한다. 즉, 트리 내의 어떤 노드와 어떤 노드까지의 경로는 반드시 있다.
        - 루트 노드: 가장 위에 있는 노드를 뜻한다. 해당 루트를 통해 탐색을 시작한다.
        - 내부 노드: 루트 노드의 리프 노드 사이에 있는 노드이다.
        - 리프 노드: 자식 노드가 없는 노드이다.

        - 깊이: 트리에서의 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리이다. 루트 노드는 깊이가 0이다.
        - 높이: 트리의 높이는 루트 노드부터 리프 노드까지의 거리 중 가장 긴 거리이다. 루트 노드만 있는 경우 높이는 0이 된다.
        - 레벨: 트리의 레벨은 주어지는 문제마다 조금씩 다르지만 보통 깊이와 같은 의미를 지닌다. 루트 노드를 레벨 0으로 두는 경우도 있고 레벨 1로 두는 경우도 있다.
        - 서브 트리: 트리 내의 하위 집합을 서브트리라고 한다. 트리 내에 있는 부분집합이라고 볼 수도 있다.
        
        - 이진 트리: 자식의 노드 수가 두 개 이하(최대 두 개)인 트리이다.
            - 정이진 트리(Full Binary Tree): 자식 노드가 0 또는 2개인 이진 트리이다.
            - 완전 이진 트리(Complete Binary Tree): 왼쪽에서부터 채워져 있는 이진 트리이다. 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 경우 왼쪽부터 채워져 있다.
            - 변질 이진 트리(Degenerate Binary Tree): 자식 노드가 하나밖에 없는 이진 트리이다.
            - 포화 이진 트리(Perfect Binary Tree): 모든 노드가 꽉 차 있는 이진 트리이다.
            - 균형 이진 트리(Balanced Binary Tree): 왼쪽과 오른쪽 노드 차이가 1 이하인 이진 트리이다. map, set를 구성하는 **레드 블랙 트리**는 균형 이진 트리 중 하나이다.
        - 이진 탐색 트리(Binary Search Tree): 노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리이다. 각 하위 트리에도 같은 성질이 적용된다. 보통 요소를 찾을 때 BST의 경우 O(logn)이 걸리지만, 최악의 경우 O(n)이 걸릴 수도 있다.
            - 최악의 경우 O(n)이 걸리는 이유는, 이진 탐색 트리는 삽입 순서에 따라 선형적일 수 있기 때문이다.
        - AVL 트리: Adelson-Velsky and Landis Tree로, BST가 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 BST이다. 두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다는 특징이 있다. 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이며 삽입, 삭제를 할 때마다 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡는다.
        - 레드 블랙 트리: 균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(logn)이다. 각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며 이는 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는 데 사용된다. C++ STL의 set, multiset, map, multimap이 레드 블랙 트리를 이용하여 구현되어 있다. '모든 리프 노드와 루트 노드는 블랙이고, 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다.' 등의 규칙을 기반으로 균형을 잡는 트리이다.
    - 힙: 완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고 해당 힙에 따라 특정한 특징을 지킨 트리이다.
        - 최대힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 한다. 각 자식의 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.
        - 최소힙: 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 작아야 한다. 각 자식의 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 한다.
        - 힙에는 어떤 값이 들어와드 특정 힙의 규칙을 지키게 만들어져 있다.
            - 힙에 새로운 요소가 들어오면 일단 새로운 노드를 힙의 마지막 노드에 이어져 삽입한다. 이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환함으로써 힙의 성질을 만족시킨다.
            - 최대힙/최소힙에서 최대값/최소값은 루트 노드이므로 루트 노드가 삭제되고, 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 과정을 거쳐 힙을 재구성한다.
    - 우선순위 큐: 우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조이다. 힙을 기반으로 구성된다.
    - 맵: 특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조이다. ``{'naver': 0, 'google': 1}`` 식으로 ``string : int`` 형태로 값을 할당해야 할 때 map을 사용한다. 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬된다. C++에서 사용할 경우 ``map<string, int>`` 형태로 사용한다. 해시 테이블을 구현할 때 쓰며, 정렬을 보장하지 않는 unordered_map과 정렬을 보장하는 map 두 형태가 있다. C++에서 맵을 순회할 때 ``key``에 해당하는 값을 **first**, key에 매핑된 ``value``를 **second**로 탐색 가능하다.
    - 셋: Set는 특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며, 중복되는 요소 없이 오로지 희소한(Unique) 값만 저장하는 자료 구조이다.
    - 해시 테이블: 무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블이다. 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가지며 unordered_map으로 구현한다.

## 데이터베이스
